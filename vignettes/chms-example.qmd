---
title: "CHMS example"
format: html
vignette: >
  %\VignetteIndexEntry{CHMS example}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

<div style="padding: 1em; background-color: #e3f2fd; border-left: 4px solid #2196F3; margin-bottom: 1em;">
**About this vignette:** All numeric values shown in this vignette are computed from the actual CHMS sample metadata files. Code is hidden by default for readability, but you can view the source `.qmd` file to see how values are calculated.
</div>

## Overview

The Canadian Health Measures Survey (CHMS) data exists only in secure data environments. This example demonstrates how to generate mock CHMS data using chmsflow metadata for testing harmonization workflows before accessing real data.

```{r setup}
#| message: false
library(MockData)
library(dplyr)
library(stringr)
```

## Load metadata

Load the CHMS harmonization metadata files that define variables and their details across cycles.

```{r load-metadata}
# CHMS sample variables
variables <- read.csv(
  system.file("extdata/chms/variables_chmsflow_sample.csv", package = "MockData"),
  header = TRUE,
  check.names = FALSE,
  na.strings = c("", "NA", "N/A"),
  stringsAsFactors = FALSE
)

# CHMS sample variable details
variable_details <- read.csv(
  system.file("extdata/chms/variable_details_chmsflow_sample.csv", package = "MockData"),
  header = TRUE,
  check.names = FALSE,
  na.strings = c("", "NA", "N/A"),
  stringsAsFactors = FALSE
)
```

The CHMS sample metadata includes `r nrow(variables)` harmonized variables with `r nrow(variable_details)` detail rows.

## Extract available cycles

```{r extract-cycles}
#| echo: false
# Extract unique cycle names from databaseStart column
cycles <- sort(unique(unlist(str_split(paste(variables$databaseStart, collapse = ","), ","))))
cycles <- str_trim(cycles[str_detect(cycles, "cycle")])
```

The sample metadata includes `r length(cycles)` CHMS cycles: `r paste(cycles, collapse = ", ")`.

## Understanding the metadata

```{r examine-cycle}
#| echo: false
# Pick the first cycle to explore
example_cycle <- cycles[1]

# Get all harmonized variables available in this cycle
cycle_vars <- get_cycle_variables(example_cycle, variables, variable_details)
```

The sample metadata includes 20 harmonized variables. For `r example_cycle`, there are `r nrow(cycle_vars)` harmonized variables available:

```{r show-cycle-vars}
#| echo: false
knitr::kable(head(cycle_vars[, c("variable", "variable_raw", "variableType", "label")], 10))
```

## Get raw variables to generate

For mock data generation, we need to create the **raw source variables** (before harmonization), not the harmonized variables.

```{r get-raw-variables}
# Get unique raw variables needed for this cycle (excludes derived variables)
raw_vars <- get_raw_variables(example_cycle, variables, variable_details,
                               include_derived = FALSE)
```

```{r compute-raw-stats}
#| echo: false
# Separate by type for easier processing
raw_cat <- raw_vars[raw_vars$variableType == "Categorical", ]
raw_con <- raw_vars[raw_vars$variableType == "Continuous", ]
```

This cycle requires `r nrow(raw_vars)` unique raw variables: `r nrow(raw_cat)` categorical and `r nrow(raw_con)` continuous.

```{r show-raw-vars}
#| echo: false
knitr::kable(raw_vars)
```

## Generate mock data for one cycle

Now let's generate mock data for a single cycle.

```{r configure-generation}
# Configuration
n_records <- 100
target_cycle <- example_cycle
seed <- 12345

# Initialize data frame
df_mock <- data.frame(id = 1:n_records)
```

We'll generate `r n_records` mock records for `r target_cycle`.

### Generate categorical variables

```{r generate-categorical}
#| echo: false
# Get raw categorical variables for this cycle
raw_cat_vars <- get_raw_variables(target_cycle, variables, variable_details,
                                   include_derived = FALSE)
raw_cat_vars <- raw_cat_vars[raw_cat_vars$variableType == "Categorical", ]

for (i in 1:nrow(raw_cat_vars)) {
  var_raw <- raw_cat_vars$variable_raw[i]

  result <- create_cat_var(
    var_raw = var_raw,
    cycle = target_cycle,
    variable_details = variable_details,
    variables = variables,
    length = n_records,
    df_mock = df_mock,
    seed = seed + i
  )

  if (!is.null(result)) {
    df_mock <- cbind(df_mock, result)
  }
}
```

Generated `r nrow(raw_cat_vars)` categorical variables. Data frame now has `r ncol(df_mock)` columns.

### Generate continuous variables

```{r generate-continuous}
#| echo: false
# Get raw continuous variables for this cycle
raw_con_vars <- get_raw_variables(target_cycle, variables, variable_details,
                                   include_derived = FALSE)
raw_con_vars <- raw_con_vars[raw_con_vars$variableType == "Continuous", ]

for (i in 1:nrow(raw_con_vars)) {
  var_raw <- raw_con_vars$variable_raw[i]

  result <- create_con_var(
    var_raw = var_raw,
    cycle = target_cycle,
    variable_details = variable_details,
    variables = variables,
    length = n_records,
    df_mock = df_mock,
    distribution = "uniform",
    seed = seed + 100 + i
  )

  if (!is.null(result)) {
    df_mock <- cbind(df_mock, result)
  }
}
```

Generated `r nrow(raw_con_vars)` continuous variables. Final data frame has `r ncol(df_mock)` columns.

### Examine the result

**Mock data structure:**

```{r examine-result}
#| echo: false
str(df_mock)
```

**First 5 rows:**

```{r show-first-rows}
#| echo: false
knitr::kable(head(df_mock, 5))
```

```{r check-missing}
#| echo: false
na_counts <- colSums(is.na(df_mock))
has_missing <- any(na_counts > 0)
```

**Missing values:** `r if(has_missing) paste(sum(na_counts > 0), "variables have missing values") else "No missing values"`

## Summary

This example demonstrated generating mock CHMS data for testing chmsflow harmonization workflows. The generated data:

-   Respects category ranges from variable_details
-   Includes appropriate missing values
-   Uses reproducible seeds
-   Can be used to test harmonization functions before accessing real CHMS data

## Next steps

-   Test your chmsflow harmonization pipeline on this mock data
-   Generate mock data for additional cycles as needed
-   Calculate derived variables after harmonization (not during mock data generation)