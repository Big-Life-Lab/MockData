---
title: "Date variables and temporal data"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: false
vignette: >
  %\VignetteIndexEntry{Date variables and temporal data}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

## Overview

MockData supports generating date variables for temporal analysis, including survival analysis and longitudinal studies. This vignette covers:

- Creating date variables from metadata
- Distribution options for realistic temporal patterns
- Generating invalid dates for testing validation pipelines
- Best practices for temporal mock data

## Basic date generation

The `create_date_var()` function generates date variables from SAS date format specifications in your metadata.

### Metadata format

Date ranges are specified in SAS date format in the `recStart` column:

```
variable,recStart,recEnd,catLabel
death_date,"[01JAN2001, 31MAR2017]","[2001-01-01, 2017-03-31]",Death date
death_date,else,NA::b,Missing
```

The function parses the SAS format and generates R `Date` objects within the specified range.

### Example: Basic date variable

```{r}
#| message: false
#| warning: false
# Load package functions
devtools::load_all("../", quiet = TRUE)

# Load metadata (use relative path for vignette building)
variable_details <- read.csv(
  "../inst/extdata/ices/variable_details.csv",
  stringsAsFactors = FALSE
)

# Generate death dates
death_dates <- create_date_var(
  var_raw = "death_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  seed = 100
)

# View sample
head(death_dates)
```

**Date range:**
```{r}
#| echo: false
cat("Minimum:", format(min(death_dates$death_date), "%Y-%m-%d"), "\n")
cat("Maximum:", format(max(death_dates$death_date), "%Y-%m-%d"), "\n")
cat("Sample size:", nrow(death_dates), "\n")
```

## Distribution options

Date variables support three distribution types to create realistic temporal patterns.

### Uniform distribution (default)

Equal probability across all dates in the range. Suitable for calendar dates with no temporal bias.

```{r}
#| eval: false
dates_uniform <- create_date_var(
  var_raw = "study_entry_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  distribution = "uniform",  # Default
  seed = 100
)
```

**Use cases:**

- Study recruitment dates
- Random calendar events
- Administrative dates

### Gompertz distribution

Events concentrate near the end of the range, following a Gompertz survival distribution. Useful for modeling mortality and age-related events.

```{r}
#| eval: false
dates_gompertz <- create_date_var(
  var_raw = "death_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  distribution = "gompertz",
  seed = 100
)
```

**Use cases:**

- Death dates (mortality increases with time)
- Disease progression events
- Age-related outcomes

**Technical details:**

- Shape parameter (η) = 0.1
- Rate parameter (b) = 0.01
- Events cluster toward end of range

### Exponential distribution

Events concentrate near the start of the range. Useful for time-to-event data where early events are more common.

```{r}
#| eval: false
dates_exponential <- create_date_var(
  var_raw = "first_hospitalization",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  distribution = "exponential",
  seed = 100
)
```

**Use cases:**

- First event occurrence
- Early disease diagnosis
- Initial treatment dates

**Technical details:**

- Rate = 1 / (range / 3)
- Mean event time at 1/3 of range
- Events decay exponentially

### Choosing a distribution

| Distribution | Pattern | Best for |
|--------------|---------|----------|
| Uniform | Flat across range | Calendar dates, random events |
| Gompertz | Increases toward end | Mortality, age-related outcomes |
| Exponential | Decreases from start | First events, early diagnoses |

### Comparing distributions

```{r}
#| message: false
#| warning: false
# Generate dates with each distribution
dates_uniform <- create_date_var(
  var_raw = "death_date", cycle = "ices",
  variable_details = variable_details,
  length = 1000, df_mock = data.frame(),
  distribution = "uniform", seed = 100
)

dates_gompertz <- create_date_var(
  var_raw = "death_date", cycle = "ices",
  variable_details = variable_details,
  length = 1000, df_mock = data.frame(),
  distribution = "gompertz", seed = 101
)

dates_exponential <- create_date_var(
  var_raw = "death_date", cycle = "ices",
  variable_details = variable_details,
  length = 1000, df_mock = data.frame(),
  distribution = "exponential", seed = 102
)

# Compare medians
cat("Median dates by distribution:\n")
cat("  Uniform:    ", format(median(dates_uniform$death_date), "%Y-%m-%d"), "\n")
cat("  Gompertz:   ", format(median(dates_gompertz$death_date), "%Y-%m-%d"), "\n")
cat("  Exponential:", format(median(dates_exponential$death_date), "%Y-%m-%d"), "\n")
```

Notice how:

- **Uniform**: Median near middle of range (2009)
- **Gompertz**: Median shifted toward end (2013) - realistic for mortality
- **Exponential**: Median shifted toward start (2005) - realistic for early events

## Missing data

Use `prop_NA` to introduce missing dates:

```{r}
#| eval: false
dates_with_na <- create_date_var(
  var_raw = "death_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  prop_NA = 0.05,  # 5% missing
  seed = 100
)

# Check missing proportion
sum(is.na(dates_with_na$death_date)) / 1000  # ~0.05
```

**Note**: Date variables use R `NA` values rather than numeric codes, even if NA codes are specified in the metadata.

## Invalid dates for testing

The `prop_invalid` parameter generates out-of-period dates to test validation pipelines.

### Basic usage

```{r}
#| message: false
#| warning: false
dates_dirty <- create_date_var(
  var_raw = "death_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  prop_invalid = 0.03,  # 3% invalid
  seed = 100
)

# Check for dates outside valid range
valid_start <- as.Date("2001-01-01")
valid_end <- as.Date("2017-03-31")

n_too_early <- sum(dates_dirty$death_date < valid_start, na.rm = TRUE)
n_too_late <- sum(dates_dirty$death_date > valid_end, na.rm = TRUE)

cat("Dates before range:", n_too_early, "\n")
cat("Dates after range:", n_too_late, "\n")
cat("Total invalid:", n_too_early + n_too_late, "out of", nrow(dates_dirty),
    sprintf("(%.1f%%)", 100 * (n_too_early + n_too_late) / nrow(dates_dirty)), "\n")
```

Example of invalid dates generated:
```{r}
#| echo: false
# Show some invalid dates
invalid_dates <- dates_dirty$death_date[
  dates_dirty$death_date < valid_start | dates_dirty$death_date > valid_end
]
cat("Sample invalid dates:\n")
cat("  Too early:", format(head(sort(invalid_dates[invalid_dates < valid_start]), 3), "%Y-%m-%d"), "\n")
cat("  Too late: ", format(head(sort(invalid_dates[invalid_dates > valid_end], decreasing = TRUE), 3), "%Y-%m-%d"), "\n")
```

### Invalid date characteristics

- **Range**: 1-5 years before start or after end
- **Distribution**: Split evenly between too-early and too-late
- **Realism**: Mimics common data entry errors

### Combining NA and invalid

```{r}
#| eval: false
dates_complex <- create_date_var(
  var_raw = "death_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 1000,
  df_mock = data.frame(),
  prop_NA = 0.02,        # 2% missing
  prop_invalid = 0.03,   # 3% invalid
  seed = 100
)

# Validation check
stopifnot(prop_NA + prop_invalid <= 1.0)  # Must sum to ≤ 1
```

## Survival analysis workflows

### Basic cohort study

Use `create_survival_dates()` to generate paired entry and event dates with guaranteed temporal ordering:

```{r}
#| message: false
#| warning: false
# Mortality study with 5-year recruitment, up to 10-year follow-up
surv_data <- create_survival_dates(
  entry_var = "cohort_entry",
  event_var = "death_date",
  entry_start = as.Date("2000-01-01"),
  entry_end = as.Date("2004-12-31"),
  followup_min = 365,       # Min 1 year follow-up
  followup_max = 3650,      # Max 10 years
  length = 1000,
  df_mock = data.frame(),
  event_distribution = "gompertz",  # Realistic mortality pattern
  seed = 100
)

# View sample
head(surv_data, 5)
```

**Key features:**

- Entry dates uniformly distributed across recruitment period
- Event dates follow Gompertz distribution (mortality increases with time)
- Guaranteed: `death_date > cohort_entry` for all records

```{r}
#| echo: false
# Calculate follow-up statistics
followup_days <- as.numeric(surv_data$death_date - surv_data$cohort_entry)
cat("Follow-up time summary (days):\n")
cat("  Median:", median(followup_days), "\n")
cat("  Range: ", range(followup_days)[1], "-", range(followup_days)[2], "\n")
cat("  Mean:  ", round(mean(followup_days)), "\n")
```

### Censoring

Add censoring to simulate incomplete follow-up:

```{r}
#| message: false
#| warning: false
surv_censored <- create_survival_dates(
  entry_var = "entry",
  event_var = "event",
  entry_start = as.Date("2010-01-01"),
  entry_end = as.Date("2015-12-31"),
  followup_min = 30,
  followup_max = 1825,  # 5 years
  length = 1000,
  df_mock = data.frame(),
  event_distribution = "exponential",
  prop_censored = 0.3,  # 30% censored
  seed = 200
)

# View structure
head(surv_censored, 5)
```

The `event_status` column indicates:

- **1** = event observed (death occurred)
- **0** = censored (lost to follow-up, end of study)

```{r}
#| echo: false
cat("Censoring summary:\n")
cat("  Events:  ", sum(surv_censored$event_status == 1),
    sprintf("(%.1f%%)", 100 * mean(surv_censored$event_status == 1)), "\n")
cat("  Censored:", sum(surv_censored$event_status == 0),
    sprintf("(%.1f%%)", 100 * mean(surv_censored$event_status == 0)), "\n")
```

### Distribution comparison for survival data

Different distributions create different event patterns:

```{r}
#| message: false
#| warning: false
# Uniform: constant hazard
surv_uniform <- create_survival_dates(
  entry_var = "entry", event_var = "event",
  entry_start = as.Date("2015-01-01"),
  entry_end = as.Date("2015-12-31"),
  followup_min = 100, followup_max = 1000,
  length = 1000, df_mock = data.frame(),
  event_distribution = "uniform", seed = 301
)

# Gompertz: increasing hazard (aging population)
surv_gompertz <- create_survival_dates(
  entry_var = "entry", event_var = "event",
  entry_start = as.Date("2015-01-01"),
  entry_end = as.Date("2015-12-31"),
  followup_min = 100, followup_max = 1000,
  length = 1000, df_mock = data.frame(),
  event_distribution = "gompertz", seed = 302
)

# Exponential: early events (diagnosis, treatment failure)
surv_exponential <- create_survival_dates(
  entry_var = "entry", event_var = "event",
  entry_start = as.Date("2015-01-01"),
  entry_end = as.Date("2015-12-31"),
  followup_min = 100, followup_max = 1000,
  length = 1000, df_mock = data.frame(),
  event_distribution = "exponential", seed = 303
)

# Compare median survival times
followup_uniform <- as.numeric(surv_uniform$event - surv_uniform$entry)
followup_gompertz <- as.numeric(surv_gompertz$event - surv_gompertz$entry)
followup_exponential <- as.numeric(surv_exponential$event - surv_exponential$entry)

cat("Median time-to-event (days):\n")
cat("  Uniform:    ", median(followup_uniform), "\n")
cat("  Gompertz:   ", median(followup_gompertz), "\n")
cat("  Exponential:", median(followup_exponential), "\n")
```

**Pattern interpretation:**

- **Uniform**: Events spread evenly across follow-up
- **Gompertz**: More events later (realistic for age-related mortality)
- **Exponential**: More events early (realistic for disease progression)

### Longitudinal studies

Generate visit dates across a study period:

```{r}
#| eval: false
# Baseline visit (uniform across recruitment period)
baseline <- create_date_var(
  var_raw = "visit_baseline",
  cycle = "cohort",
  variable_details = variable_details,
  length = 500,
  df_mock = data.frame(),
  distribution = "uniform",
  seed = 200
)

# Follow-up visits would be generated relative to baseline
# (Currently manual - see planned temporal constraints in parking-lot.md)
```

### Testing data validation

Generate realistic errors for pipeline testing:

```{r}
#| eval: false
# Create test data with multiple error types
test_dates <- create_date_var(
  var_raw = "death_date",
  cycle = "ices",
  variable_details = variable_details,
  length = 10000,
  df_mock = data.frame(),
  prop_NA = 0.02,
  prop_invalid = 0.01,
  seed = 300
)

# Test your validation function
validate_dates <- function(dates, min_date, max_date) {
  errors <- list()

  # Check for missing
  if (any(is.na(dates))) {
    errors$missing <- sum(is.na(dates))
  }

  # Check for out-of-range
  valid_dates <- dates[!is.na(dates)]
  if (any(valid_dates < min_date | valid_dates > max_date)) {
    errors$out_of_range <- sum(
      valid_dates < min_date | valid_dates > max_date
    )
  }

  return(errors)
}

# Run validation
errors <- validate_dates(
  test_dates$death_date,
  min_date = as.Date("2001-01-01"),
  max_date = as.Date("2017-03-31")
)

print(errors)
```

## Best practices

### Seed management

Use different seeds for different date variables to ensure independence:

```{r}
#| eval: false
birth_dates <- create_date_var(..., seed = 100)
death_dates <- create_date_var(..., seed = 101)
diagnosis_dates <- create_date_var(..., seed = 102)
```

### Distribution selection

1. **Start with uniform** for calendar dates without known patterns
2. **Use Gompertz** for mortality and age-related outcomes
3. **Use exponential** for first-event or early-diagnosis scenarios
4. **Validate** against real data distributions when possible

### Temporal constraints

**Current limitation**: MockData v0.2.0 does not enforce temporal relationships between dates (e.g., birth < death).

**Workarounds**:

- Generate dates independently and post-process
- Use appropriate distributions to minimize violations
- Document assumptions in your code

**Future**: See [parking-lot.md](../parking-lot.md) for planned `after`/`before` parameters in v0.3.0.

### Testing strategies

1. **Test both valid and invalid data**:
   ```r
   # Valid data for algorithm testing
   clean_dates <- create_date_var(..., prop_invalid = 0)

   # Dirty data for validation testing
   dirty_dates <- create_date_var(..., prop_invalid = 0.05)
   ```

2. **Use realistic error proportions**:
   - Real surveys: 1-5% invalid
   - Administrative data: 0.1-1% invalid
   - Manual entry: 5-10% invalid

3. **Document your assumptions**:
   ```r
   # Generate dates with 3% invalid to match historical error rate
   # from 2015-2017 data linkage (see docs/data-quality-report.pdf)
   test_dates <- create_date_var(..., prop_invalid = 0.03)
   ```

## Limitations and future enhancements

### Current limitations

- No automatic temporal constraints between dates
- Limited distribution options (3 types)
- No support for recurrent events
- No time-varying covariates

### Planned features

See [parking-lot.md](../parking-lot.md) for:

- **Temporal constraints** (v0.3.0): `after`, `before` parameters
- **Survival helpers** (v0.3.0): `create_survival_vars()`
- **Recurrent events** (v0.4.0): Multiple events per subject
- **Time-varying covariates** (v0.5.0): Variables that change over time

## See also

- [User guide](user-guide.html) - Comprehensive feature documentation
- [DemPoRT example](demport-example.html) - Applied survival analysis workflow
- [Advanced topics](advanced-topics.html) - Custom distributions and workflows
- `?create_date_var` - Function reference
